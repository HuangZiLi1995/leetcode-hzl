# 每次只能反转一位，则从最低一位开始反转即[0,1]
# 然后逐步反转高位，先取0，后取1
# 将0加到已经反转的低位上，值不变
# 将1加到反转的低位上，值要加上这个高位代表的值
# 并且对于已经反转的低位而言，要与前一半保持对称，还需逆序
class Solution:
    def grayCode(self, n: int) -> List[int]:
        if n == 0: return [0]
        # 初始化第一位res，i为位数，j为该位的值
        i, j, res = 1, 1, [0, 1]
        while i < n:
            i += 1
            j *= 2
            # 前一半高位加0，后一半逆序，高位加1
            res += [r+j for r in res[::-1]]
        return res
# 时间复杂度O(2**n)
# 空间复杂度O(2**n)
