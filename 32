# 动态规划
# 一个字符串结尾为')'，若其前一字符为'('，则可形成'()'
# 若其前一字符为')'，则可越过该字符形成的括号对，与再前一字符形成'(括号对)'
# 形成括号对后可拼接上前一个字符形成的括号对
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        # 去掉肯定无用的字符
        s = s.lstrip(')')
        s = s.rstrip('(')
        # 如果字符串为空，则放回0
        if not s: return 0
        # 存储字第i个字符为结尾的最长有效括号
        dp = [0] * len(s)
        for i in range(1, len(s)):
            # 不可能以(结果
            if s[i] == '(':
                dp[i] = 0
            else:
                # 如果前一个为(，则可与前一个字符形成一个括号对
                # 其可以拼接上以第i-2的字符结尾的括号对
                if s[i-1] == '(':
                    dp[i] = 2
                    if i > 1:
                        dp[i] += dp[i-2]
                # 如果前一个字符为)，则不能与前一个字符形成括号对
                # 但可越过前一个字符形成的括号对，再与前一个字符形成括号对
                # 最后拼接上再前一个字符形成的括号对
                else:
                    a = i-dp[i-1]-1
                    if a>-1 and s[a]=='(':
                        dp[i] = dp[i-1]+2
                        if a > 0:
                            dp[i] += dp[a-1]
        return max(dp)
# 时间复杂度O(n):遍历字符串
# 空间复杂度O(n):dp长度为n
